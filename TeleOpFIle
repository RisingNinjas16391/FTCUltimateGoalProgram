/* Copyright (c) 2019 FIRST. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted (subject to the limitations in the disclaimer below) provided that
 * the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list
 * of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * Neither the name of FIRST nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior written permission.
 *
 * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
 * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.firstinspires.ftc.teamcode;

import android.util.Log;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;

import org.firstinspires.ftc.robotcore.external.ClassFactory;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
import org.firstinspires.ftc.robotcore.external.matrices.VectorF;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;

import java.util.ArrayList;
import java.util.List;

import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;
import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;

@TeleOp(name = "Run This TeleOp Stupid", group = "Teleop")
public class TeleOpReworked extends LinearOpMode {

    final double shootingAngle = -0.1;
    final double shootTolerance = 2;
    final double wheelDiameter = 3.54331; //in inches
    final double encoderTicksPerRotation = 28 * 20; //bare motor * gear ratio
    final double wheelDisplacement = wheelDiameter * 2 * Math.PI / encoderTicksPerRotation; //Angular movement per encoder tick

    //odometry settings
    org.firstinspires.ftc.teamcode.HardwareMecanumReworked robot = new org.firstinspires.ftc.teamcode.HardwareMecanumReworked();   //Uses heavily modified untested hardware
    int[] lastTick = {0, 0, 0, 0};
    double[] globalPosition = {0, 0};
    boolean flyIdle = false;
    boolean latch = false;
    boolean readyGrip = true;
    double flySet = 0;
    double[] deltaPosition = {0, 0};
    double powerShotAngle = 2;
    private final ElapsedTime runtime = new ElapsedTime();
    private final ElapsedTime motorTime = new ElapsedTime();

    @Override
    public void runOpMode() {
        waitForStart();

        /* Initialize the hardware variables.
         * The init() method of the hardware class does all the work here
         */
        robot.init(hardwareMap);
        robot.driveTrain.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.trigger.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.arm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.driveTrain.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.flywheel.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.trigger.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.driveTrain.toggleBrake(true);
        robot.flywheel.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        robot.trigger.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        robot.arm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);


        // PID HISTORY
        //robot.flywheel.setVelocityPIDFCoefficients(1.343, .0743, 0.1, 13.43);
        //mathematically computed original values: 1.707, 0.1707, 0, 17.07
        //Mr. Allsworth's baller status idea #1: 2, 0.1707, 0, 17.07
        //Mr. Allsworth's LeBron James idea #2: 1.707, 0.1800, 0, 17.07
        //John Wang's poopoo idea #1: 1.727, 0.1800, 0, 17.07
        //John Wang's "idea" #2: 1.707, 0.1790, 0, 17.07
        //Massimo's dank idea #1: 1.475, 0.182, 0, 17.07
        // John's CRAZY idea 5, .45, 0, 50.07
        //1.07, .1825, 0, 17.07

        // Send telemetry message to signify robot waiting;
        telemetry.addData("Say", "Hello Driver");    //
        telemetry.update();
        waitForStart();
        while (opModeIsActive()) {

            runDriver1();
            runDriver2();

            computePos();
            displayTelemetry();
            // Pace this loop so jaw action is reasonable speed.
            sleep(25);
        }
    }


    public void runDriver1() {

        //Shooting commands
        if (gamepad1.left_bumper) {
            runtime.reset();
            robot.trigger.setPower(1);
            robot.trigger.setTargetPosition(820);
            while (robot.trigger.getCurrentPosition() < 818 && runtime.milliseconds() < 3000) {
                robot.trigger.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            }
        } else if (gamepad1.right_bumper) {
            runtime.reset();
            robot.trigger.setPower(0.82);
            robot.trigger.setTargetPosition(2480);
            while (robot.trigger.getCurrentPosition() < 2478 && runtime.milliseconds() < 3000) {
                robot.trigger.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            }
        }

        //IMU odometry adjustment
        if (gamepad1.a) {
            turnToAngle(shootingAngle);
        }
        else if (gamepad1.y){
            driveIndividual(0, 80, 0, 80, 500);
        }
        else if (gamepad1.x) {
            shootSingle();
            driveIndividual(300,-300, -300, 300, 1000);
        }
        else {
            // Driving
            if (gamepad1.left_stick_button) {
                robot.driveTrain.driveMecanum((gamepad1.left_stick_y),
                        (gamepad1.left_stick_x),
                        (gamepad1.right_stick_x + gamepad1.right_trigger / 4 - gamepad1.left_trigger / 4));
            } else {
                robot.driveTrain.driveMecanum((gamepad1.left_stick_y) * 0.6,
                        (gamepad1.left_stick_x * 0.6),
                        (gamepad1.right_stick_x + gamepad1.right_trigger / 4 - gamepad1.left_trigger / 4) / 2);
            }

        }
        robot.driveTrain.getCurrentPosition();
    }


    public void runDriver2() {
        //shooting
        if (gamepad2.left_trigger > .25) {
            robot.trigger.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
            robot.trigger.setPower(-gamepad2.left_trigger * .4);
        } else {
            robot.trigger.setTargetPosition(0);
            robot.trigger.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.trigger.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
            robot.trigger.setPower(gamepad2.right_trigger);
        }

        if (gamepad2.left_stick_y > .25) {
            robot.arm.setPower(gamepad2.left_stick_y);
        } else if (gamepad2.left_stick_y < -.25) {
            robot.arm.setPower(gamepad2.left_stick_y);
        } else {
            robot.arm.setPower(0);
        }

        // intake system
        if (gamepad2.right_bumper) {
            robot.intake.setPower(1);
        } else if (gamepad2.left_bumper) {
            robot.intake.setPower(-1);
        } else {
            robot.intake.setPower(0);
        }

        // WOBBLE GOAL // Tractor limits are 0 (all the way up) and -2300 (all the way down)
        if (gamepad2.dpad_up) {
            if (robot.arm.getCurrentPosition() > -5) {
                robot.arm.setPower(-.1);
            } else {
                robot.arm.setPower(0.55);
            }
        } else if (gamepad2.dpad_down) {
            readyGrip = true;
            robot.arm.setTargetPosition(-2200);
            robot.arm.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.arm.setPower(-0.5);
        } else {
            robot.arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.arm.setPower(0);
        }

        // CLAW
        if (gamepad2.dpad_left) {
            robot.claw.setPower(.3);
            latch = false;
        } else if (gamepad2.dpad_right) {
            robot.claw.setPower(-.3);
            latch = false;
//        } else if (gamepad2.dpad_right || latch) {
//            runtime.reset();
//            int tractorPos = robot.arm.getTargetPosition() - 300;
//            robot.arm.setTargetPosition(tractorPos);
//            if (readyGrip) {
//                robot.arm.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//                robot.arm.setPower(-.5);
//            } else {
//                robot.arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//                robot.arm.setPower(0);
//                readyGrip = false;
//            }
//            robot.claw.setPower(-.25);
//            latch = true;
        } else {
            robot.claw.setPower(0);
            latch = true;
        }

        // SHOOTER
        if (gamepad2.x) {
            flySet = .74;  //was 72 2/16                               ,
            //flySet = 2280;
            flyIdle = false;
        } else if (gamepad2.y) {
            flySet = 0.72;
            // flySet = 2050;
            flyIdle = false;
        } else if (gamepad2.b) {
            flySet = .60;
            //flySet = 1330;
            flyIdle = false;
        } else if (gamepad2.a) {
            flySet = 0;
            flyIdle = true;
        }
        robot.flywheel.setPower(flySet);
    }


    public void displayTelemetry() {
        // TELEMETRY
//            telemetry.addLine("left | ")
//                    .addData("forward", robot.frontLeft.getCurrentPosition())
//                    .addData("rear", robot.rearLeft.getCurrentPosition());
//
//            telemetry.addLine("right | ")
//                    .addData("forward", robot.frontRight.getCurrentPosition())
//                    .addData("rear", robot.rearRight.getCurrentPosition());

        telemetry.addLine("Flywheel | ")
                .addData("Speed: ", flySet)
                .addData("Idle: ", flyIdle)
                .addData("Velocity: ", robot.flywheel.getVelocity());

        telemetry.addLine("Trigger | ")
                .addData(" Pos: ", robot.trigger.getCurrentPosition())
                .addData(" Tar: ", robot.trigger.getTargetPosition());

        telemetry.addLine("Odometry | ")
                .addData("IMU heading", robot.lastAngles.firstAngle)
                .addData("Global Heading", robot.imu.getAngle())
                .addData("DeltaPos", deltaPosition[0])
                .addData("GlobalPos", globalPosition[0]);

        telemetry.addLine("Drive")
                .addData("FrontLeft", robot.driveTrain.frontLeft.getCurrentPosition())
                .addData("FrontRight", robot.driveTrain.frontRight.getCurrentPosition())
                .addData("BackLeft", robot.driveTrain.rearLeft.getCurrentPosition())
                .addData("BackRight", robot.driveTrain.rearRight.getCurrentPosition());

        telemetry.addLine("arm")
                .addData("Position", robot.arm.getCurrentPosition());

        telemetry.update();
    }


    public void turnToAngle(double angle) {
        robot.imu.getAngle();
        double heading = robot.lastAngles.firstAngle;
        double speed = Math.abs(((heading) / 30) + .1);
        double tolerance = 0.2;
        if (heading < angle - tolerance) {
            robot.driveTrain.driveMecanum(0, 0, -speed);
        } else if (heading > angle + tolerance) {
            robot.driveTrain.driveMecanum(0, 0, speed);
        }
    }

    public void turnToAngle2(double angle) {
        robot.imu.getAngle();
        double heading = robot.lastAngles.firstAngle;
        double speed = Math.abs(((heading) / 25) + .06);
        double tolerance = 2;
        if (heading < angle - tolerance) {
            robot.driveTrain.driveMecanum(0, 0, -speed);
        } else if (heading > angle + tolerance) {
            robot.driveTrain.driveMecanum(0, 0, speed);
        } else if ((heading > angle - tolerance)&&(heading < angle + tolerance)) {
            robot.driveTrain.driveMecanum(0, 0, 0);
        }
    }

    public void shootingPowerShots(int frontLeft, int frontRight, int rearLeft, int rearRight, double timeOut) {
        final double stallTorque = .4;

        robot.driveTrain.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.driveTrain.setPower(0);
        robot.driveTrain.driveGroup[0].setTargetPosition(-frontLeft);
        robot.driveTrain.driveGroup[1].setTargetPosition(-frontRight);
        robot.driveTrain.driveGroup[2].setTargetPosition(-rearLeft);
        robot.driveTrain.driveGroup[3].setTargetPosition(-rearRight);
        robot.driveTrain.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        robot.driveTrain.toggleBrake(true);
        runtime.reset();

        while (opModeIsActive() && !isStopRequested() && (runtime.milliseconds() < timeOut)
                && (robot.driveTrain.frontRight.isBusy() || robot.driveTrain.frontLeft.isBusy()
                || robot.driveTrain.rearLeft.isBusy() || robot.driveTrain.rearLeft.isBusy())) {

            if (!opModeIsActive() || isStopRequested()) {
                return;
            }

            // Display it for the driver.
            telemetry.addLine("left")
                    .addData("forward", robot.driveTrain.frontLeft.getCurrentPosition())
                    .addData("rear", robot.driveTrain.rearLeft.getCurrentPosition());
            telemetry.addLine("right")
                    .addData("forward", robot.driveTrain.frontRight.getCurrentPosition())
                    .addData("rear", robot.driveTrain.rearRight.getCurrentPosition());
            telemetry.addData("Time Elapsed", runtime.milliseconds());
            telemetry.addLine("left target")
                    .addData("forward target", robot.driveTrain.frontLeft.getTargetPosition())
                    .addData("rear target", robot.driveTrain.rearLeft.getTargetPosition());
            telemetry.addLine("right target")
                    .addData("forward target", robot.driveTrain.frontLeft.getTargetPosition())
                    .addData("rear target", robot.driveTrain.rearLeft.getTargetPosition());

            for (int i = 0; i < 4; i++) {
                if (!opModeIsActive() || isStopRequested()) {
                    return;
                }
                double percentPath = (double) robot.driveTrain.driveGroup[i].getCurrentPosition() / (double) robot.driveTrain.driveGroup[i].getTargetPosition();
                double out = stallTorque + 1.45 * percentPath - 1.7 * Math.pow(percentPath, 2);
                robot.driveTrain.driveGroup[i].setPower(out);
                Log.i("TELEMETRY", String.format("Drive %d Encoder Ticks: %d", i, robot.driveTrain.driveGroup[i].getCurrentPosition()));
            }
            telemetry.update();
        }
    }

    public void driveIndividual (int frontLeft, int frontRight, int rearLeft, int rearRight, double timeOut) {
        final double stallTorque = .4;

        robot.driveTrain.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.driveTrain.setPower(0);
        robot.driveTrain.driveGroup[0].setTargetPosition(-frontLeft);
        robot.driveTrain.driveGroup[1].setTargetPosition(-frontRight);
        robot.driveTrain.driveGroup[2].setTargetPosition(-rearLeft);
        robot.driveTrain.driveGroup[3].setTargetPosition(-rearRight);
        robot.driveTrain.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        robot.driveTrain.toggleBrake(true);
        runtime.reset();

        while (opModeIsActive() && !isStopRequested() && (runtime.milliseconds() < timeOut)
                && (robot.driveTrain.frontRight.isBusy() || robot.driveTrain.frontLeft.isBusy()
                || robot.driveTrain.rearLeft.isBusy() || robot.driveTrain.rearLeft.isBusy())) {

            if ( !opModeIsActive() || isStopRequested()) {
                return;
            }

            // Display it for the driver.
            telemetry.addLine("left")
                    .addData("forward", robot.driveTrain.frontLeft.getCurrentPosition())
                    .addData("rear", robot.driveTrain.rearLeft.getCurrentPosition());
            telemetry.addLine("right")
                    .addData("forward", robot.driveTrain.frontRight.getCurrentPosition())
                    .addData("rear", robot.driveTrain.rearRight.getCurrentPosition());
            telemetry.addData("Time Elapsed", runtime.milliseconds());
            telemetry.addLine("left target")
                    .addData("forward target", robot.driveTrain.frontLeft.getTargetPosition())
                    .addData("rear target", robot.driveTrain.rearLeft.getTargetPosition());
            telemetry.addLine("right target")
                    .addData("forward target", robot.driveTrain.frontLeft.getTargetPosition())
                    .addData("rear target", robot.driveTrain.rearLeft.getTargetPosition());

            for (int i = 0; i < 4; i ++) {
                if ( !opModeIsActive() || isStopRequested()) {
                    return;
                }
                double percentPath = (double) robot.driveTrain.driveGroup[i].getCurrentPosition() / (double) robot.driveTrain.driveGroup[i].getTargetPosition();
                double out = stallTorque + 1.45 * percentPath - 1.7 * Math.pow(percentPath, 2);
                robot.driveTrain.driveGroup[i].setPower(out);
                Log.i("TELEMETRY", String.format("Drive %d Encoder Ticks: %d", i, robot.driveTrain.driveGroup[i].getCurrentPosition()));
            }
            telemetry.update();
        }

        // Stop all motion;
        robot.driveTrain.toggleBrake(true);

        // Turn off RUN_TO_POSITION
        robot.driveTrain.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // Makes robot stop
        robot.driveTrain.setPower(0);

    }

    public void shootSingle(){
        runtime.reset();
        robot.trigger.setTargetPosition(840);
        robot.trigger.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.trigger.setPower(.70);
        while (robot.trigger.getCurrentPosition() < 840 && runtime.milliseconds() < 1000 && robot.trigger.isBusy()) {
            telemetry.addData("Shooting",true);
        }
        robot.trigger.setPower(0);
        robot.trigger.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
    }

    public void computePos() {
        //Compute change in encoder positions
        int[] currentTick = robot.driveTrain.getCurrentPosition();
        double[] deltaTick = new double[4];
        double[] displaced = new double[4];
        double[] robotDisplacement = new double[4];
        double sum = 0;
        double[] deltaPositionRot = new double[2];

        for (int i = 0; i < 4; i++) {
            //Compute change in encoder positions
            deltaTick[i] = currentTick[i] - lastTick[i];
            //Compute displacements for each wheel
            sum += displaced[i] = deltaTick[i] * wheelDisplacement;
        }

        //Compute the average displacement in order to untangle rotation from displacement
        double displacementAverage = sum / 4;

        for (int i = 0; i < 4; i++) {
            //Compute the component of the wheel displacements that yield robot displacement
            robotDisplacement[i] = displaced[i] - displacementAverage;
        }

        //Compute the displacement of the holonomic drive, in robot reference frame
        deltaPositionRot[0] = (robotDisplacement[0] + robotDisplacement[1] - robotDisplacement[2] - robotDisplacement[3]) * Math.sqrt(2);
        deltaPositionRot[1] = (robotDisplacement[0] - robotDisplacement[1] - robotDisplacement[2] + robotDisplacement[3]) * Math.sqrt(2);

        //Move this holonomic displacement from robot to field frame of reference
        double robotTheta = robot.globalAngle / 2 * Math.PI;
        double sinTheta = Math.sin(robotTheta);
        double cosTheta = Math.cos(robotTheta);
        deltaPosition[0] = deltaPositionRot[0] * cosTheta - deltaPositionRot[1] * sinTheta;
        deltaPosition[1] = deltaPositionRot[1] * cosTheta + deltaPositionRot[0] * sinTheta;

        //Update the position
        globalPosition[0] = globalPosition[0] + deltaPosition[0];
        globalPosition[1] = globalPosition[1] + deltaPosition[1];
        lastTick = currentTick;
    }

}
